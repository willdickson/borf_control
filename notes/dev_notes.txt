dev_notes.txt - borf_control development notes

Will Dickson 06/12/2008 - 
==============================================

Stability problem. The current incarnation of borf_control has a
pretty serious stability issue which causes it to hard lock
intermittently. I'm not sure what is causing this - it may have
something to do with shared memory usage. This set of notes has been
started to help me keep track of my debugging effort. 

A couple of ideas. 

* I think the stability problem has to due with shared memory as the
  problem typically seems to occur when access or freeing the shared
  memory between the realtime driver and the user space library. 

  One thought is that I need to use mlock on the shared memory buffers.
  
  A second idea is that it is a race condition. I might try commenting
  out all spin locks in motor_ctl driver. 

------------------------------------------------------------------------

* Found that rt_global_heap_open() is required for user space
  processes using shared memory.

  Action: 
  
  In motor_shm.c I've added a rt_global_heap_open() to the section of
  code just after the rt_shm_alloc's and a rt_global_heap_close() the
  the section just after the rt_shm_free's.

  Result:

  This didn't seem to fix the problem and stress.py still hard locks
  the system after running about 20-40 kinematic patterns. The final
  command on the debugging output was *cmd2motor_ctl set-os-buffer.
  I'm going to check this out.  

  In addition because of the hard locks I should back up all the debs
  required to make this system. and all the src packages.

  Note, I'm going to keep the rt_global_heap open and close functions
  in motor_shm.c as the rtai documentation and example seem to suggest
  they are required. 

------------------------------------------------------------------------

* Looking at cmd2motor_ctl set-os-buffer. 

  Could there be a race condition in motor_ctl.c? I can't see anything
  obvious. 

  Action: 
  
  Try removing all spinlocks and see what happens. This could mess up
  the behavior of the system in and of itself, but it should get into
  a race condition. I just might be that some of the variables are
  garbage when they are accessed. 

  Result:
  

-------------------------------------------------------------------------

* Maybe I need to lock my shared memory buffers in use space

  Action:
  
  In motor_shm.c try adding a mlock to each of the shared memory
  buffers after allocation and a munlock before freeing them.
   
  Result:

-------------------------------------------------------------------------

* Is shared memory access the problem

  Action: 

  Try removing alla writes from user space to shared memory.

  Result:

-------------------------------------------------------------------------


